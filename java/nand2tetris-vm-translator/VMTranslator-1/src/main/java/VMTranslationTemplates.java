import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import util.Utils;

import java.io.IOException;
import java.text.MessageFormat;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * A singleton <a href="https://www.tutorialspoint.com/how-to-make-a-singleton-enum-in-java">enum</a> to load and
 * provide the templates to translate the various VM commands.
 */
public enum VMTranslationTemplates {

    INSTANCE;

    private final Logger logger = LoggerFactory.getLogger(VMTranslationTemplates.class);

    public record Template(String template, boolean needsAutoGeneratedIndex) {
    }

    private final Map<String, Map<String, Template>> commandMap = new HashMap<>();

    private static final String KEY_FOR_COMMAND_WITHOUT_MODIFIER = "key for command without modifier";

    public static final String[] COMMANDS_WITHOUT_MODIFIERS =
            {"add", "sub", "neg", "eq", "lt", "gt", "and", "or", "not"};

    VMTranslationTemplates() {
        final Map<String, Template> pushCommandMap = new HashMap<>();
        putTemplateInMap(pushCommandMap, "constant", "templates/push-constant.asm", false);
        putTemplateInMap(pushCommandMap, "temp", "templates/push-registry.asm", false);
        putTemplateInMap(pushCommandMap, "local", "templates/push-segment.asm", true, "LCL");
        putTemplateInMap(pushCommandMap, "argument", "templates/push-segment.asm", true, "ARG");
        putTemplateInMap(pushCommandMap, "this", "templates/push-segment.asm", true, "THIS");
        putTemplateInMap(pushCommandMap, "that", "templates/push-segment.asm", true, "THAT");
        putTemplateInMap(pushCommandMap, "static", "templates/push-registry.asm", false);
        putTemplateInMap(pushCommandMap, "pointer", "templates/push-registry.asm", false);

        final Map<String, Template> popCommandMap = new HashMap<>();
        putTemplateInMap(popCommandMap, "temp", "templates/pop-registry.asm", false);
        putTemplateInMap(popCommandMap, "local", "templates/pop-segment.asm", true, "LCL");
        putTemplateInMap(popCommandMap, "argument", "templates/pop-segment.asm", true, "ARG");
        putTemplateInMap(popCommandMap, "this", "templates/pop-segment.asm", true, "THIS");
        putTemplateInMap(popCommandMap, "that", "templates/pop-segment.asm", true, "THAT");
        putTemplateInMap(popCommandMap, "static", "templates/pop-registry.asm", false);
        putTemplateInMap(popCommandMap, "pointer", "templates/pop-registry.asm", false);

        final Map<String, Template> noArgCommandMap = new HashMap<>();
        putTemplateInMap(noArgCommandMap, "eq", "templates/compare.asm", true, "JEQ");
        putTemplateInMap(noArgCommandMap, "lt", "templates/compare.asm", true, "JLT");
        putTemplateInMap(noArgCommandMap, "gt", "templates/compare.asm", true, "JGT");
        putTemplateInMap(noArgCommandMap, "add", "templates/arithmetic-or-logic-binary.asm", false, "+");
        putTemplateInMap(noArgCommandMap, "sub", "templates/arithmetic-or-logic-binary.asm", false, "-");
        putTemplateInMap(noArgCommandMap, "and", "templates/arithmetic-or-logic-binary.asm", false, "&");
        putTemplateInMap(noArgCommandMap, "or", "templates/arithmetic-or-logic-binary.asm", false, "|");
        putTemplateInMap(noArgCommandMap, "neg", "templates/arithmetic-or-logic-unary.asm", false, "-");
        putTemplateInMap(noArgCommandMap, "not", "templates/arithmetic-or-logic-unary.asm", false, "!");

        commandMap.put("push", pushCommandMap);
        commandMap.put("pop", popCommandMap);
        // this is a bit unorthodox as it uses a fake key as the command and the command (eq, lt, etc.) as the modifier
        commandMap.put(KEY_FOR_COMMAND_WITHOUT_MODIFIER, noArgCommandMap);
    }

    /**
     * @param needsAutoGeneratedIndex whether the template being added contains a placeholder that needs to be replaced
     *                                with an auto-generated index (e.g., @COMP.{0}.TRUE/@COMP.{0}.FALSE/@COMP.{0}.END,
     *                                etc. for `eq')
     */
    private void putTemplateInMap(Map<String, Template> map, String command, String templateResource,
            boolean needsAutoGeneratedIndex, Object... args) {
        try {
            final String template = MessageFormat.format(Utils.getStringFromResource(templateResource), args).trim();
            map.put(command, new Template(template, needsAutoGeneratedIndex));
        } catch (IOException e) {
            logger.error("Error reading file `" + templateResource + "'", e);
            map.put(command, new Template(templateResource + " not found", needsAutoGeneratedIndex));
        }
    }

    /**
     * @return the template for a {@code command} without modifiers (e.g., eq, lt, etc.)
     */
    public Template getTemplate(String command) {
        return commandMap.getOrDefault(KEY_FOR_COMMAND_WITHOUT_MODIFIER, Collections.emptyMap()).get(command);
    }

    /**
     * @return the template for a {@code command} with {@code modifier} (e.g., push constant, pull that, etc.)
     */
    public Template getTemplate(String command, String modifier) {
        return commandMap.getOrDefault(command, Collections.emptyMap()).get(modifier);
    }
}
