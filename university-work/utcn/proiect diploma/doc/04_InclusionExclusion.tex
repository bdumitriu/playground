\chapter{Issues Regarding Operation-Based Merging}
\label{chap:incexcl}

As we mentioned in section \ref{sec:cmm}, \emph{operation-based merging} is the
technique of merging two document versions into one by working on two logs of
operations (each of which describes the set of operations an original
version of the document has gone through in order to transform itself into its current
form). In this chapter we take a closer look to what \emph{operation-based merging}
is, the specific issues associated with it and what its advantages over its
``competitor'', \emph{state-based merging}, are. We will also introduce the
notions of inclusion and exclusion transformation in the context of
\emph{operation-based merging}, explain why they are necessary and define
both their actual implementation and some functions based on these transformations
that will be used in our algorithm.

\section{Operations}

In an operation-based model, the \emph{operation} represents the fundamental
concept the whole system revolves around. Simply put, an operation is an
action the user can perform in order to modify a document (to change it from one
state to another). Generally, by means of an operation a certain part of the
document is changed, either by adding something to it or by deleting something
from it or by changing its properties. Depending on the type of editor we are
dealing with, an operation can take very different forms. In a text editor,
for instance, example of possible operations would be \emph{insert character}
and \emph{remove character}. If, on the other hand, we are working with a
graphical editor, example of possible operations are \emph{create figure},
\emph{change foreground color} or \emph{delete figure}. Operations can also
be composed in order to create higher level operations (a series of
\emph{insert character}'s, for example, could be combined to form a single
\emph{insert word} operation).

The principle behind operation-based merging is that the delta between two
versions of a document is stored as a list of operations which have been
executed on the original version of the document in order to obtain its current
version. In this context, we preferred using the operational approach instead of
the state-based one in this project because operations are more finely grained
than the deltas generated by state comparison (as it is common to do in state-based
merging). This is because their effect region can begin at any character in a
document and contain an arbitrary number of characters (instead of only being
able to refer entire lines, for example). Moreover, by using the operation-based
approach, the activity of the users can be tracked, because the operations
they perform are stored in a log, thus maintaining information about the
evolution of the document from one state into another.

In what text editing is concerned, there are two general types of primitive
operations: \emph{insert} and \emph{delete}, denoted (in a generic manner) as
\mbox{\emph{Insert}/\emph{Delete}[p, s]} (inserting/deleting string s at/from
position p in the document). We will use this notation later on in this chapter
when discussing the inclusion and exclusion transformations.

Another very important operation-related concept (in what cooperative editing
is concerned) is known as the \emph{intention} of an operation. The following
definition of the term is taken from \cite{sun98a}:

\begin{defi}
The \emph{intention} of an operation $O$ is the execution effect which
can be achieved by applying $O$ on the document state from which $O$ was generated.
\end{defi}

For the sake of clarity, we mention that the effect of an operation exclusively
refers to its syntactic effect (meaning the insertion and deletion of characters
at specific positions in the document) and not to its semantic effect (for example,
changing a verb from present to past or vice-versa). What the concept of the intention
of an operation is needed for will become obvious in the following sections.

\section{A consistency model}

Previous theoretical approaches that have looked into the specific issues of
cooperative editing systems (see \cite{sun96}) have shown that there are several
properties that such a system has to maintain in order for it to be considered
consistent. However, before actually discussing these properties, let us first
try to explain how a cooperative editing system can become inconsistent
if special care is not taken.

\subsubsection{Divergence}

The problem of divergence especially appears in real-time cooperative systems,
but we can easily show that asynchronous systems have to deal with it as well.
The divergence issue usually arises in real-time cooperative systems when
operations arrive at different sites in different orders, resulting in different
final results. For instance, if users at two sites are working on the same document
and they each just execute a single operation and send it to the other one, the
results will probably be different (unless the operations are commutative, but
this is usually not the case). This is because at site 1 operation $O_{1}$ (the operation
executed at site 1) is executed first and operation $O_{2}$ (the one from site 2)
second, while at site 2 the order of execution is reversed ($O_{2}$ first and then
$O_{1}$).

A similar situation can occur in an asynchronous configuration as well. Take, for
instance, the case when two users (John and Mary) edit the same document and John
commits before Mary (this is \emph{always} the case since no two - or more - users
can commit at the same time). Before the Mary can commit herself, she will have
to do an update (see section \ref{sec:cmm}) in order to integrate the changes 
John has made. But Mary has obviously made her own changes to the document
(i.e. has executed a set of operations on the document). Now, let us suppose that
she simply executes John's operations on her working copy and then commits it
to the repository. John, on the other hand, wanting himself to update his own
version (so that it contains Mary's changes), will, say, take the current
version from the repository (the one containing Mary's changes) and execute
the operations therein on his working copy. We have come to the exact same case
as with real-time editing, when both users have executed the same operations,
but their versions of the document differ. This is because they have executed
the operations in different order and the operations are \emph{not} commutative.

The divergence problem is usually solved in real-time collaborative editing systems
by means of a serialization protocol, so that operations are sure to be executed
in the exact same order on all sites. This is, however, not possible in the case
of an asynchronous system because executing operations in the same order on all
sites usually implies an undo-execute-redo scheme (``undo'' of (local) operations already
executed, ``execute'' of operations that should precede them in the serial order,
and ``redo'' of the undone operations; this scheme is necessary because of the need
to ensure good local responsiveness, which implies executing the local operations
as soon as they are generated, without waiting for those remote ones which might
precede them in the serial order). The undo-execute-redo scheme is impossible to
apply in asynchronous systems because operations on the repository cannot be
undone and interleaved with others since this would lead to further inconsistencies
between clients (some might have updated with one set of operations and some with
another, modified, set of operations and all would think that they have the same
version of the document when, in fact, this wouldn't be true). Different techniques
thus have to be found in order to ensure convergence of document versions when
dealing with asynchronous editing. The way our system solves the divergence problem
will be detailed in chapter \ref{chap:algorithm}.

\subsubsection{Causality-violation}

Due to the nondeterministic communication latency, operations may arrive to a site
and be executed out of their natural \emph{cause-effect} order. For instance, consider
the case of two operations, $O_{1}$ (generated on site 1) and $O_{2}$
(generated on site 2), such that $O_{2}$ is dependent on $O_{1}$ (i.e. site 2 had already
received $O_{1}$ when $O_{2}$ was generated). Suppose that, due to different communication
delays over the network, $O_{2}$ arrives at, say, site 3 before $O_{1}$. This is a typical
case of causality-violation, because $O_{2}$ might need some effect that $O_{1}$ produces in
order for it to make sense (let us assume that $O_{1}$ is the insertion of a sentence
in a document and $O_{2}$ is the insertion of a word inside that sentence; it is obvious
that if the sentence does not exist, it makes no sense to try inserting a word in
it).

This type of inconsistency is particular to real-time collaborative editing systems
only and thus does not appear in the case of asynchronous systems. The reason for
this is that communication in the asynchronous case takes place only between
two end points (the client and the repository). And when multicast does not appear,
a situation like the one depicted above is impossible to appear. When only unicast
is involved, operations that one site (the client/the repository) sends to the other
(the repository/the client) are sure to arrive at the destination in the same order
in which they were issued by the source (\emph{Note: this statement no longer holds
if the transport protocol used for communication does not guarantee in order delivery
of messages}).

Given the fact that this paper is dealing with asynchronous editing systems, we
shall pursue the matter of causality-violation no further, referring the reader to
\cite{sun96} for additional information. 

\subsubsection{Intention-violation}

Due to the fact that operations are generated concurrently, the effect of an operation
when executed on a site may be different from the intended effect of the operation
at the time of its generation. This means that the user who generated the operation
might have wanted to insert a letter in a certain word (say), while the \emph{actual}
effect of the execution of that operation (on a different site) might be the insertion
of the letter in a different word. This violation of user intention comes from the
fact that the context in which the operation was generated and the context in which
it is executed are effectively different (here, we use context as an equivalent of
document state). For example, if an operation $O_{1}$ is generated on a document in state $S_{1}$
and later executed (in the exact same form) on the same document, but in state $S_{2}$ (which
is obtained, for instance, by executing operation $O_{2}$ in state $S_{1}$), it will possibly
achieve a different effect than intended because the position argument of
$O_{1}$ (remember that we consider an operation in a text editing system to be of the
form Insert/Delete[p, s], with p the position and s the string to insert/delete) might
no longer refer the same logical position in the document. More concrete
examples of this can be found later in this chapter, when inclusion and exclusion
transformations are introduced.
\\
\\
Although a clear distinction between divergence and intention-violation might be
a bit difficult to see, still one does exist. The essential difference between the
two comes from the fact that divergence can always be avoided by using a serialization
protocol while this does not hold in the case of intention-violation (i.e. as long
as operations are executed in their original form there is no serialization protocol
which can ensure intention-preservation). 

In light of the problems described above we can finally return to defining the consistency
model mentioned in the title of this section. The original form of the definition
(as it appears in \cite{sun96}) is appropriate for real-time systems. We shall firstly
present it in this form and then make some notes regarding aspects peculiar to asynchronous
systems.

\begin{defi}
A cooperative editing system is said to be consistent if it always maintain the following
properties:

\begin{enumerate}
\item \textbf{Convergence}: when the same set of operations have been executed at all
      sites, all copies of the shared document are identical.
\item \textbf{Causality-preservation}: for any pair of operations $O_{a}$ and $O_{b}$,
      if $O_{a}\to{}O_{b}$, then $O_{a}$ is executed before $O_{b}$ on all sites.
\item \textbf{Intention-preservation}: for any operation $O$, the effects of executing
      $O$ at all sites are the same as the intention of $O$, and the effect of executing
      $O$ does not change the effects of independent operations.
\end{enumerate}
\end{defi}

\textit{Note: ``$\to$'' denotes the \emph{causal ordering relation}, the exact definition
of which is beyond the scope of this paper. For an intuitive explanation of the concept,
please refer to the example given in the subsection called ``Causality-violation''.}

In a nutshell, the \emph{convergence} property ensures that users on all sites will eventually
have the exact same final result once the editing session is finished; the \emph{causality-preservation}
property guarantees an ordering of the execution of operations which takes causality into
account; while the \emph{intention-preservation} says that the effect achieved by the
execution of an operation at a remote site is identical to the one achieved by its
execution at the originating site and also that the effects of independent operations
do not overlap. The consistency model is both a promise to the user and a contract for
the developers of cooperative systems.

As we have shown previously, in the case of asynchronous systems the problem of
causality-preservation no longer appears due to the nature of communication between
the end-points in the system. In what divergence and intention-violation are
concerned, however, these problems do arise in the asynchronous case as well. The way
we have solved these issues in this project will be discussed in detail in chapter
\ref{chap:algorithm}. In what follows we will only try to explain it in just a few
words for the sake of completeness. During this explanation, the concept of
inclusion is used, so you might want to jump to section \ref{sec:intention}, read
that first and then return back here and read on.

The basic idea is that we do not use a serialization protocol in order to apply
operations in the same order on all sites, but instead we work with transformations
of the sets of operations. The situation we always have to deal with in the asynchronous
system is that of a client doing an update from the repository. Thus, we always have
two sets of operations we have to merge (the local set of operations and the remote
set of operations). The local operations have already been executed locally and
they will not be undone. What we do is we transform both sets of operations (the
local and the remote set) so that each of them properly includes the effects of the
operations in the other one, thus obtaining two modified sets. For purposes of this
discussion, we shall call these two modified sets the \emph{transformed local log}
and the \emph{execution form of the remote log}. Once this transformation of
operations is completed, the execution form of the remote log is executed locally
in order to update the local working copy with the changes from the repository.
Since the remote operations have been modified in order to include the effect of
the local operations, intention-preservation is ensured (see next section). On the
other hand, the transformed local log is sent back (committed) to the repository.
This log contains the operations that had been executed locally, but modified so
that they include the effect of the operations from the repository. By doing this
we ensure that the intention of the local operations will be preserved as well
when they will be executed by another client (again, see next section).

By applying this technique we not only achieve intention-preservation, but
convergence as well. In order to understand this fact, consider the cas of two users working in
parallel (John and Mary). Suppose they both start working from the same version
of the document. John does his changes, Mary does hers and then they both want
to update in order to integrate the changes of the other. Let us suppose Mary
commits her changes first. John will have to start by updating his working copy
in order for it to include Mary's changes and then commit his own changes
to the repository. When updating, the algorithm will transform Mary's operations
so that they include the effect of John's. But in the same time, it will change
John's operations so that they include the effect of Mary's. John will then
execute the execution form of Mary's operations on his working copy and commit
his own transformed local log. When Mary finally updates, the repository will
send her John's transformed local log, which she will execute on her own 
working copy of the document. At this point, they both have the same version
of the document. The convergence of the two copies is ensured by means of the
merging algorithm, which guarantees that the sets of operations will be transformed
in such a way that the same effect will be achieved on both sites. Why
this is indeed true will become clearer once you read the description of the
merging algorithm from chapter \ref{chap:algorithm}.

\section{Achieving intention-preservation}
\label{sec:intention}

Achieving intention-preservation is much harder than achieving convergence (and
causality-preservation). This is because the intention-violation problem is not
related to the execution order of operations and cannot be resolved by just
rescheduling operations, as in the case of achieving convergence and
causality-preservation. To achieve intention-preservation, an operation has
to be transformed before its execution in order to compensate the changes made to the
document state by other executed operations \cite{sun96}. To better understand
why this is so, let us begin this section by offering two real life examples of
intention-violation.

\subsection{The ``inclusion'' problem}

Suppose that the initial version of a document is:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We dance and the music dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

Also, suppose that two users start working on this document in the same time, creating
the following two different version:

\begin{center}
\begin{tabular}[c]{cc}

% line 1
John & Mary

\\

% line 2
\begin{tabular}[c]{|c|}
\hline
We dance and the music \textcolor{red}{slowly} dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
&
\begin{tabular}[c]{|c|}
\hline
We dance and music dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}

\end{tabular}
\end{center}

which, in terms of operations, would be translated to:

\begin{center}
\begin{tabular}[c]{cc}

% line 1
John & Mary

\\

% line 2
\begin{tabular}[c]{|c|}
\hline
\textcolor{red}{Insert[23, 'slowly ']}\\
\hline
\end{tabular}
&
\begin{tabular}[c]{|c|}
\hline
\textcolor{blue}{Delete[13, 'the ']}\\
\hline
\end{tabular}

\end{tabular}
\end{center}

Suppose now that John commits his changes to the repository, i.e. sends a list of operations
containing just one entry: \{Insert[23, 'slowly ']\}. Mary, wanting to integrate John's
changes, does an update and receives from the repository the exact same list of operations
that John previously committed, i.e. \{Insert[23, 'slowly ']\}. Say
Mary would simply execute the operations from the list (in this case, the single operation)
in the form in which she received them. The result she would obtain would be:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We dance and music dies\textcolor{red}{slowly }.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

instead of:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We dance and music \textcolor{red}{slowly} dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

This is because the \emph{context} in which Mary executes John's operation is different
from the \emph{context} in which the operation was originally created. The context has
changed because Mary has executed an operation of her own (i.e. the Delete[13, 'the ']
operation), thus changing the state of the document. Therefore, position 23 from John's
operation no longer refers the same \emph{logical} position in the document as John
intended. The actual effect of this is the insertion of the string 'slowly ' on
position 23 in Mary's context, which is right after the word 'dies', resulting in the
wrong sentence. This is a typical case of user intention-violation. The obvious solution
to this problem is to modify John's operation so that it \emph{includes} the effect
of that of Mary's. In this case, what the system has to do is subtract the value 4
(the length of the deleted string 'the ') from position 23 and thus change the insert
operation to Insert[19, 'slowly ']. Applying this operation in Mary's context would
lead to the correct version of the document. 

This is essentially an example of the ``inclusion'' problem.

\subsection{The ``exclusion'' problem}

This time, let us focus on what happens on just one site, since in the case of the
``exclusion'' problem this will suffice. Again, let us start our discussion from the
following initial state of a document:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We dance and the music dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

The user deletes the word 'the' in order to obtain:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We dance and music dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

and then inserts the word 'slowly' to reach this form:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We dance and music \textcolor{red}{slowly} dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

or, in terms of operations:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
\textcolor{red}{Delete[13, 'the ']}\\
\textcolor{red}{Insert[19, 'slowly ']}\\
\hline
\end{tabular}
\end{center}

Now, for reasons independent of our user, something happens and his first operation,
Delete[13, 'the '] is found to be conflicting with some other user's operation and has
to be canceled (reasons why this might happen will be given in chapter \ref{chap:algorithm};
for now, let us just assume that it has to happen). Under these circumstances, if
the second operation, Insert[19, 'slowly '], which was not conflicting, and thus did
not have to be canceled, is kept unmodified, a re-execution of the local log,
currently of the form \{Insert[19, 'slowly ']\}, on the initial state of the document,
would yield:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We dance and the mu\textcolor{red}{slowly }sic dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

which is obviously wrong. However, this is exactly what a different user (virtually)
executing this list of operations (a list, in this case, containing just one operation)
would obtain. The reason why this happens is, once again, the fact that the context
in which the operation was generated and the context in which it is executed are
essentially different. The resolution, however, is different here, since it no
longer involves including the effect of another operation into the current one,
but \emph{excluding} it. In our case, the effect of the operation Delete[13, 'the ']
has to be \emph{excluded} from the operation Insert[19, 'slowly ']. The latter
would then become Insert[23, 'slowly '] (we have added 4 - the length of the deleted
string - to the value 19 and obtained position 23). Apply this transformed operation
effectively preserves the user intention:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We dance and the music \textcolor{red}{slowly} dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

This second example illustrated the typical case of the ``exclusion'' problem.

\subsection{Context of operations}

Now that we have outlined a rough idea of why inclusion and exclusion transformations
are necessary we shall next try to approach the problem from a more theoretical
perspective and properly define the above mentioned transformations this way.

The first term that appeared in the examples above was that of \emph{operation
context}. Conceptually, an operation $O$ is associated with a \emph{context}, denoted
as $CT_{O}$, which is the list of operations that need to be executed to bring the
document from its initial state to the state on which $O$ is defined. The importance
of a context is that the effect of an operation can only be interpreted correctly
when it is executed in the context in which it was defined. More rigorously,
\cite{shen02} defines this concept as:

\begin{defi}
Given an operation $O$, its \emph{context}, denoted as $CT_{O}$, is the document
state on which $O$'s parameters are defined.
\end{defi}

Given an initial document state, $S_{0}$, and a list of operations $L=[O_{1},\ldots,O_{n}]$
performed on $S_{0}$, the current document state is denoted as $S_{0}\circ{}L=S_{0}\circ{}
[O_{1},\ldots,O_{n}]$. So $CT_{O}=S_{0}$, $CT_{O_{i}}=CT_{O_{i-1}}\circ{}[O_{i-1}]$ $(1 < i \leq{}n)$.
The context of an operation can be changed by explicitly applying the inclusion and
exclusion transformations (see \ref{sec:incexcl}).

A concept related to that of operation context, and one which will allow us to specify the
pre- and post-conditions of transformation functions, is that of \emph{context equivalence}:

\begin{defi}
Given two operations, $O_{a}$ and $O_{b}$, $O_{a}$ is \emph{context equivalent} $O_{b}$,
denoted as $O_{a} \sqcup  O_{b}$, iff $CT_{O_{a}}=CT_{O_{b}}$.
\end{defi}

It is important to remember, for the part of this paper where we discuss the merging
algorithm, that an essential precondition for analyzing whether two operations are
conflicting or not is that they have to be context equivalent. This analysis of the
two operations would be done by a conflict-detection function. If this precondition
is not ensured, then the conflict-detection function will most likely return an erroneous result,
since it would have no way of knowing that the two operations actually have different
contexts. To illustrate how this could happen, consider the following example. For its
purposes, let us just assume that our conflict-detection function returns
\emph{true} (i.e. that the two operations received as parameters are conflicting)
if both operations represent changes of the same word.

Assume the initial state of the document is:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We dance and the music dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

One user successively generates the following two operations:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
\textcolor{red}{$O_{11}$ = Insert[3, 'all ']}\\
\textcolor{red}{$O_{12}$ = Insert[12, 'd']}\\
\hline
\end{tabular}
\end{center}

in order to change the document to:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
We \textcolor{red}{all} dance\textcolor{red}{d} and the music dies.\\
We run through the stars.\\
We are without excuse.\\
\hline
\end{tabular}
\end{center}

while the other user simply deletes the letters 'n' and 'd' from the word 'and' by
performing:

\begin{center}
\begin{tabular}[c]{|c|}
\hline
\textcolor{blue}{$O_{21}$ = Delete[10, 'nd']}\\
\hline
\end{tabular}
\end{center}

In this situation, the conflict-detection function, when analyzing $O_{12}$ and $O_{21}$ in order
to detect whether they are conflicting or not, will reason that positions 12 and 10 (the
positions of the two operations) refer to the same word (namely the word 'and'). Since
both operations refer to the same word they are in conflict by definition so the function
will return true. As you might have noticed, this answer would be wrong because, in fact,
the two operations did not refer to the same word ($O_{12}$ referred to the word 'dance'
and $O_{21}$ referred to the word 'and'). The erroneous judgment is due to the fact that
it does not hold that $O_{12} \sqcup O_{21}$, which is exactly the point we were trying
to make.

Generally speaking, if we have two lists of operations $L_{1}=[O_{1}^{1},\ldots,O_{m}^{1}]$
and $L_{2}=[O_{1}^{2},\ldots,O_{n}^{2}]$ performed on the same base version, it is true
that $O_{1}^{1} \sqcup O_{1}^{2}$, but it is not true that $O_{i}^{1} \sqcup O_{j}^{2}$ 
$(1 < i \le m,1 \le j \le n)$. Since this is the case we will usually have to deal with
when doing the merging phase of the algorithm, special care will have to be taken that
we always transform operations in the two lists in such a way that whenever we compare
two of them it will hold that they are context equivalent, thus avoiding problems as
the one illustrated above.

The last concept which will help us define the inclusion and exclusion transformations
is that of \emph{context preceding relation}.

\begin{defi}
\label{def:cprec}
Given two operations $O_{a}$ and $O_{b}$, $O_{a}$ is \emph{context preceding} $O_{b}$,
denoted as $O_{a} \mapsto O_{b}$, iff $CT_{O_{b}}=CT_{O_{a}} \circ [O_{a}]$.
\end{defi}

Given a log of operations $L=[O_{1},\ldots.O_{n}]$, since all these operations have been
executed sequentially by the same user (and thus each of them including the effects of all
the ones preceding it), it is necessarily true that $O_{i-1} \mapsto O_{i}$ $(1 < i \le n)$.
Suppose that an operation $O_{k}$ cannot be re-executed and has to be excluded from the
log. We cannot simply take it out and execute all the operations following it as if nothing
had changed. If we think of $O_{k+1}$, for example, it was defined on the document state
after the execution of $O_{k}$ and therefore cannot be executed as is on the document state
before the execution $O_{k}$. In order to omit $O_{k}$, operations $O_{k+1},\ldots,
O_{n}$ must be transformed to achieve $O_{k-1} \mapsto O_{k+1}$ and $O_{j} \mapsto O_{j+1}$
$(k+1 \le j < n)$ and only then can they be correctly executed.

\subsection{Inclusion and exclusion transformations}
\label{sec:incexcl}

We have presented several problems throughout this chapter that all basically reduce to
the same issue, namely the necessity of employing a way to transform operations so that
they can be executed in a different context than the one in which they were generated and achieve
the same effect as originally intended by the user who performed them. The exact same
transformations have to be used in order to ensure the aforementioned necessary precondition
for correctly reasoning about possibly conflicting operations.

The two types of transformations we need to introduce are the \emph{inclusion} and the
\emph{exclusion} transformations. These are defined in \cite{sun96} as follows:

\begin{defi}
To include operation $O_{b}$ into the context of $O_{a}$, the \emph{inclusion transformation}
function $IT(O_{a},O_{b})$ is called to produce $O'_{a}$, as specified below:
\\
\\
Specification. $IT(O_{a},O_{b}):O'_{a}$
\begin{enumerate}
\item Precondition for input parameters: $O_{a} \sqcup O_{b}$.
\item Postcondition for output: $O_{b} \mapsto O'_{a}$, where $O'_{a}$'s execution
      effect in the context of $CT_{O'_{a}}$ is the same as $O_{a}$'s execution effect
      in the context of $CT_{O_{a}}$.
\end{enumerate}
\end{defi}

\begin{defi}
To exclude operation $O_{b}$ from the context of $O_{a}$, the \emph{exclusion transformation}
function $ET(O_{a},O_{b})$ is called to produce $O'_{a}$, as specified below:
\\
\\
Specification. $ET(O_{a},O_{b}):O'_{a}$
\begin{enumerate}
\item Precondition for input parameters: $O_{b} \mapsto O_{a}$.
\item Postcondition for output: $O_{b} \sqcup O'_{a}$, where $O'_{a}$'s execution
      effect in the context of $CT_{O'_{a}}$ is the same as $O_{a}$'s execution
      effect in the context of $CT_{O_{a}}$.
\end{enumerate}
\end{defi}

In a simpler form, the inclusion transformation function transforms operation $O_{a}$
against $O_{b}$ in such a way that the impact of $O_{b}$ is effectively included in the
parameters of the output operation $O'_{a}$ if $O_{a} \sqcup O_{b}$, while the exclusion
transformation function transforms $O_{a}$ against $O_{b}$ in such a way that the impact
of $O_{b}$ is effectively excluded from the parameters of the output operation $O'_{a}$
if $O_{a} \mapsto O_{b}$.

The form in which we actually encode the inclusion and exclusion transformations in our
algorithm will be presented in chapter \ref{chap:algorithm}. In the same chapter we will
also show how these transformations can be combined in order to achieve more complex
effects which our algorithm requires.
